RavelIndex â† {idxğ•Šshape: +Â´ idx Ã— Ã—`âŒ¾ âŒ½  1Â« shape}
_setmany_ â† {i _ğ•£_ v x: vâŒ¾ ((RavelIndexâŸœ(â‰¢x)Â¨ i)âŠ¸âŠâˆ˜â¥Š) x}

nudges â† {â¥Š > ğ•©â‹ˆÂ¨'v'â¥ŠËœâ‰ ğ•©}  âŠ‘â€¢FLines âŠ‘â€¢args
shapes â† âŒ½ Â¨ âŸ¨[1â€¿1â€¿1â€¿1], [0â€¿1â€¿0, 1â€¿1â€¿1, 0â€¿1â€¿0], [0â€¿0â€¿1, 0â€¿0â€¿1, 1â€¿1â€¿1], â‰ â‰[1,1,1,1], [1â€¿1, 1â€¿1]âŸ©
ModIdx â† {iğ•Šx: xâŠ‘Ëœi|Ëœâ‰ x}

width â† 7
margin â† 3
System â‡ {ğ•Š:
  t_nudge â‡ 0
  t_rock â‡ 0
  board â† 100â€¿width â¥Š 0
  h â‡ 0
  AddToBoard â† {boardğ•Šxâ€¿shape:
    i â† xâŠ¸+Â¨ shape /â—‹â¥Š â†•â‰¢shape
    (i _setmany_ (1Â¨i)) board
  }
  SimulateRockâ‡ {ğ•Šğ•©:
    shape â† t_rock ModIdx shapes
    shâ€¿sw â† â‰¢shape
    t_rock +â†© 1
    # compute starting height, if necessary double board height to make room
    jstart â† h + margin
    {(jstart+sh)â‰¥â‰ board ? board â†© board âˆ¾ 0Â¨ board; @}
    x â† âŸ¨jstart, 2âŸ©
    {ğ•Šğ•©:
      nudge â† t_nudge ModIdx nudges
      t_nudge +â†© 1
      dx â† {'v': Â¯1â€¿0; '<': 0â€¿Â¯1; '>': 0â€¿1} nudge
      newx â† x+dx
      inbounds â† âˆ§Â´ (0â€¿0â‰¤newx) âˆ§ ((newx+â‰¢shape)â‰¤â‰¢board)
      overlap â† {inbounds ? âˆ¨Â´ âŠ‘âŸœboardÂ¨ (newxâŠ¸+Â¨ shape /â—‹â¥Š â†•â‰¢shape); 0}
      {inbounds âˆ§ Â¬overlap? x â†© newx;
       nudge='v'? board (AddToBoardâŸœxâ€¿shape)â†© â‹„ shape â†© @ â‹„ h âŒˆâ†© (sh+âŠ‘x);  # come to rest
       @}
    }â€¢_while_{ğ•Šğ•©:
      Â¬shapeâ‰¡@
    } @
  }
  State â‡ {ğ•Š:
    âŸ¨t_rock|Ëœâ‰ shapes, t_nudge|Ëœâ‰ nudgesâŸ©
  }
}

# part one: 2022 rocks
a â† System @
a.SimulateRockâŸ 2022 @
â€¢Show a.h

# part two: 1E12 rocks. too big to fit the board in memory, and even if we could, we
# wouldn't have the time to simulate so many rocks. the system eventually becomes
# periodic. I ended up peeking at dzaima's solution to figure out how exactly to
# exploit that, and I ended up stealing his OO approach in the process.
b â† System @
b.SimulateRockâŸ 1000 @                          # warm up and take note of state
h1 â† b.h â‹„ n1 â† b.t_rock â‹„ state â† b.State @
b.SimulateRock @
b.SimulateRock â€¢_while_ {ğ•Š: stateâ‰¢b.State @} @  # run until state is revisited
h2 â† b.h â‹„ n2 â† b.t_rock
# we simulated `n1` rocks, and found the same state after `n2` more rocks.
# so we can tell that every `n2 - n1` rocks, h increases by `h2 - h1`.
# this lets us predict the h after n1+k*(n2-n1) rocks for integer k.
# the desired 1E12 will not be a nice multiple like that, so we need to simulate a
# few more steps.
ntotal â† 1E12
b.SimulateRock âŸ ((n2 - n1) | (ntotal - n1)) @
h3 â† b.h

â€¢Show h1 + (h3 - h2) + (h2 - h1) Ã— âŒŠ(ntotal - n1) Ã· (n2 - n1)

