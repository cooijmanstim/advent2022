lines â† â€¢FLines âŠ‘â€¢args
ParseNat â† 10âŠ¸Ã—âŠ¸+ËœÂ´ âˆ˜âŒ½ -âŸœ'0'
ParseNum â† {ğ•Šğ•©: '-'â‰¡âŠ‘ğ•© ? -ParseNat 1â†“ğ•©; ParseNat ğ•©}
Numbers â† {ğ•Šs: ParseNumÂ¨ s âŠ”Ëœ {1-Ëœğ•©Ã—+`0âŒˆğ•©-Â»ğ•©} ('-'=s) âˆ¨ (('0' â‰¤ s) âˆ§ (s â‰¤ '9'))}
Split â† {ğ•¨ğ•Šğ•©: ğ•©âŠ”ËœÂ¯1+ ğ•¨((Â¬âˆ˜=)Ã—(1âŠ¸+âˆ˜(+`âˆ˜=)))ğ•©}
FillDiagonal â† {(ğ•¨ â¥ŠËœâ‰ ğ•©)âŒ¾ (0â€¿0âŠ¸â‰ ) ğ•©}

nodes â† {ğ•Šline:
  aâ€¿b â† ';' Split line
  node â† 2â†‘(â‰ "Valve ")â†“a
  rate â† âŠ‘Numbers a
  successors â† Â¯2â†‘Â¨ ',' Split b
  âŸ¨node, rate, successorsâŸ©
}Â¨ lines

# turn node names into numeric identifiers, so we can use a vector/matrix representation of the graph
names â† âŠ‘Â¨ nodes
identifiers â† âŠ names
rates â† 1âŠ¸âŠ‘Â¨ nodes
tunnels â† > {ğ•Šnameâ€¿rateâ€¿successors:
  i â† {âŠ‘namesâŠ<ğ•©}Â¨ successors
  (1Â¨i)âŒ¾ (iâŠ¸âŠ) âˆÂ¨ identifiers
}Â¨ nodes
# compute minimum distances between nodes
distances â† 0 FillDiagonal tunnels
{ğ•Šk:
  distances âŒŠâ†© distances +âŒœâ—‹(kâŠ¸âŠ) â‰ distances
}Â¨ â†•â‰ distances

RemoveNode â† {kğ•Švâ€¿râ€¿e:  # remove node k from the graph
  m â† Â¬k=â†•â‰ v
  v â†© m / v â‹„ r â†© m / r â‹„ e â†© {ğ•©âŠâŒ¾â‰ ğ•©âŠe} /m
  vâ€¿râ€¿e
}

graph â† {ğ•Švâ€¿râ€¿e:
  # now remove zero-rate nodes (except starting node AA)
  vâ€¿râ€¿e â†© vâ€¿râ€¿e RemoveNodeÂ´ /((Â¬"AA"âŠ¸â‰¡Â¨v)âˆ§0=r)
  # permute nodes so that start is at index zero
  i â† â’ "AA"âŠ¸â‰¡Â¨ v
  v â†© iâŠv â‹„ r â†© iâŠr â‹„ e â†© i âŠâŒ¾â‰ iâŠe
  vâ€¿râ€¿e
} namesâ€¿ratesâ€¿distances
start â† 0

F â† {ğ•ŠâŸ¨t, score, bestscore, node, graph, pathâŸ©:
  {score +â†© tÃ—nodeâŠ‘1âŠ‘graph â‹„ graph 0âŒ¾ ((nodeâŠ¸âŠ‘)âˆ˜(1âŠ¸âŠ‘))â†©
   #{score > bestscore?  â€¢Show âŸ¨"new best score", score, âŠ‘âŸœ(âŠ‘graph)Â¨ pathâŸ©; @}

   #ubound â† score++Â´(0âŒˆ(t-2Ã—1+â†•â‰ 1âŠ‘graph))Ã—âˆ¨1âŠ‘graph  # if we opened remaining valves from big to small, assuming distance 1 between them
   ubound â† score + +Â´ (0âŒˆt-1+nodeâŠ2âŠ‘graph)Ã—1âŠ‘graph  # if we opened remaining valves, assuming we can go to each of them in parallel, but taking distance into account
   #ubound â† score++Â´(tÃ—1âŠ‘graph)  # if we opened all valves right now
   {bestscore < ubound ?
    successors â† {(0<ğ•©âŠ1âŠ‘graph)/ğ•©} â’1âŠ‘graph  # consider next valves in descending order
    bestscore âŒˆâ†© score
    {ğ•Šdest:
      dt â† 1+ nodeâ€¿dest âŠ‘ 2âŠ‘graph  # +1 minute to open valve
      (0 < t-dt) ?
      bestscore âŒˆâ†© F âŸ¨t-dt, score, bestscore, dest, graph, pathâˆ¾<destâŸ©
      ; @
    }Â¨ successors
    ;@}
   bestscore
  }
}

# part one
â€¢Show F âŸ¨30, 0, 0, start, graph, âŸ¨âŸ©âŸ©

# for part two, consider all partitions of the rate>0 nodes into two subsets
# NOTE currently broken on the example, getting 1704 instead of 1707.
bestscore â† 0
{ğ•Šğ•©:
  a â† 1+/ ğ•© â‹„ b â† 1+/ (Â¬ğ•©)  # 1+ to account for start node at index 0
  tmax â† 26
  ubound â† +Â´ {+Â´(tmax-1+ğ•©âŠstartâŠ2âŠ‘graph)Ã—ğ•©âŠ1âŠ‘graph}Â¨ aâ€¿b  # if we travelled to each valve in parallel and opened it
  (bestscore < ubound) âˆ§ (a>â—‹â‰ b) ?  # a>â—‹â‰ b to avoid processing twice (complements)
    ascore â† F âŸ¨tmax, 0, 0, start, graph RemoveNodeÂ´ a, âŸ¨âŸ©âŸ©
    bscore â† F âŸ¨tmax, 0, 0, start, graph RemoveNodeÂ´ b, âŸ¨âŸ©âŸ©
    #{bestscore<ascore+bscore ? â€¢Show âŸ¨"new best score", ascore+bscore, a, bâŸ©; @}
    bestscore âŒˆâ†© ascore + bscore
  ;@
}Â¨ â¥Š â†•2Â¨â†•Â¯1+â‰ âŠ‘graph  # Â¯1+ to not partition start node
â€¢Show bestscore

