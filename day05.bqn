lines â† â€¢FLines âŠ‘â€¢args

# a bitch to parse!
# first find the empty line
emptyidx â† âŠ‘ 0âŠËœ â‰ Â¨ lines
# examine the line above it to find out how many stacks there are
baseline â† (emptyidx-1) âŠ‘ lines
stackindices â† / baseline > '0'
stacklines â† âŒ½  (emptyidx-1) â†‘ lines
# a matrix [ZN ,MCD,P  ]
stacks â† â‰ > stackindicesâŠ¸âŠÂ¨ stacklines
# convert to list of lists, trim spaces on the right
stacks â†© â€¢Show {(âˆ¨âŸœÂ«' 'âŠ¸â‰ )âŠ¸/}Â¨ <Ë˜stacks

# part one: play out the moves to figure out what's on the top of each stack at the end
Split â† (âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢
ParseInt â† (10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½-âŸœ'0')
movelines â† (emptyidx+1) â†“ lines
finalstacks â† stacks {
  parts â† ' ' Split ğ•¨
  n â† ParseInt 1âŠ‘parts
  src â† 1-Ëœ ParseInt 3âŠ‘parts
  dst â† 1-Ëœ ParseInt 5âŠ‘parts
  # remake ğ•© (stacks) but with `dst` and `src` rows modified
  boxes â† nâ†‘âŒ½ (srcâŠ‘ğ•©)
  boxes âŒ½ â†© # for part two only
  newsrc â† âŒ½ nâ†“âŒ½ srcâŠ‘ğ•©
  newdst â† (dstâŠ‘ğ•©) âˆ¾ boxes
  #â€¢Show âŸ¨ğ•¨, n, src, dst, newsrc, newdstâŸ©
  (â†•â‰ ğ•©) {iğ•Šx:  # rebuild ğ•© by mapping over enumeration of rows
    {i â‰¡ src ? newsrc ; i â‰¡ dst ? newdst; x}
  }Â¨ ğ•©
}Â´ âŒ½ movelines  # reverse because fold is back-to-front
â€¢Show Â¯1âŠ¸âŠ‘Â¨ finalstacks

