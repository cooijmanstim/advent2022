nodes â† âˆ§ {
  name â† 4â†‘ğ•©
  expr â† {('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') âŠ‘ğ•© ? 10âŠ¸Ã—âŠ¸+ËœÂ´âŒ½ ğ•©-'0';
                             âŸ¨4â†‘ğ•©, 5âŠ‘ğ•©, 7â†“ğ•©âŸ©} 6â†“ğ•©
  nameâ€¿expr
}Â¨ â€¢FLinesâŠ‘â€¢args

MaybeEval â† {opğ•Šaâ€¿b:
{âˆ§Â´1=â€¢TypeÂ¨ aâ€¿b ? ((âŠ‘"+-*/="âŠop) âŠ‘ +â€¿-â€¿Ã—â€¿Ã·â€¿=)Â´ aâ€¿b
                ; aâ€¿opâ€¿b}
}
MakeTree â† {ğ•Šnodes:
  root â† âŠ‘(âŠ‘Â¨nodes)âŠ<"root"
  {F aâ€¿opâ€¿b: op MaybeEval {F 1âŠ‘nodesâŠ‘ËœâŠ‘(âŠ‘Â¨nodes)âŠ<ğ•©}Â¨ aâ€¿b;
   ğ•©
  } 1âŠ‘rootâŠ‘nodes
}

{ # part one
  â€¢Show MakeTree nodes
}

{ # part two: derive value of "humn" from setting "root"'s children equal
  # luckily "humn" only appears once in the tree.
  tree â† MakeTree {
    "root"â€¿expr: âŸ¨"root", âŸ¨âŠ‘expr, '=', 2âŠ‘exprâŸ©âŸ©;
    "humn"â€¿expr: âŸ¨"humn", @âŸ©;
    ğ•©: ğ•©
  }Â¨ nodes
  aâ€¿Â·â€¿b â† tree
  aâ€¿b â†© âˆ¨aâ€¿b  # let a be the constant branch and b be the dependent branch
  â€¢Show {F aâ€¿b: # now invert the operations on b until @ remains
    # unpack b
    {@: a;
     câ€¿opâ€¿d: {0â€¿1: {'+': FâŸ¨a-d,câŸ©; '-': FâŸ¨a+d,câŸ©; '*': FâŸ¨aÃ·d,câŸ©; '/': FâŸ¨aÃ—d,câŸ©} op; # expr  Ã— const
              1â€¿0: {'+': FâŸ¨a-c,dâŸ©; '-': FâŸ¨c-a,dâŸ©; '*': FâŸ¨aÃ·c,dâŸ©; '/': FâŸ¨cÃ·a,dâŸ©} op  # const Ã— expr
             } 1= â€¢TypeÂ¨ câ€¿d
    } b
  } aâ€¿b
}

