b â† âŠ‘Â¨ "^v<>#."âŠ¸âŠÂ¨ > â€¢FLinesâŠ‘â€¢args
upâ€¿downâ€¿leftâ€¿rightâ€¿wall â† bâŠ¸=Â¨â†•5

Step â† {uâ€¿dâ€¿lâ€¿r:
  u  1âŠ¸âŒ½ âŒ¾ (((1âŠ¸â†“)âˆ˜(Â¯1âŠ¸â†“)))â†©
  d Â¯1âŠ¸âŒ½ âŒ¾ (((1âŠ¸â†“)âˆ˜(Â¯1âŠ¸â†“)))â†©
  l  1âŠ¸âŒ½ âŒ¾ (((1âŠ¸â†“)âˆ˜(Â¯1âŠ¸â†“))âˆ˜â‰ )â†©
  r Â¯1âŠ¸âŒ½ âŒ¾ (((1âŠ¸â†“)âˆ˜(Â¯1âŠ¸â†“))âˆ˜â‰ )â†©
  uâ€¿dâ€¿lâ€¿r
}
ShowState â† {ğ•Šudlr:
  counts â† +Â´ udlr â‹„ indices â† +Â´ udlr Ã—Â¨ 1+â†•4
  â€¢Show wall {ğ•¨ ? '#'; ğ•©}Â¨ indices {ğ•©>1? ğ•©+'0'; ğ•©=1? ğ•¨ âŠ‘ ".âˆ§âˆ¨<>"; '.'}Â¨ counts
}
Expand â† {ğ•Šfâ€¿udlr:
  (Â¬wallâˆ¨Â´udlr) âˆ§ f âˆ¨Â´â¥Š Â«â€¿Â» {ğ•âŒ¾ğ• f}âŒœ âŠ¢â€¿â‰
}
MeasurePath â† {aâ€¿bğ•Štâ€¿udlr:
  {udlr Stepâ†© â‹„ t +â†© 1 â‹„ Expand ğ•©â€¿udlr}â€¢_while_{Â¬bâŠ‘ğ•©} 1âŒ¾ (aâŠ¸âŠ‘) 0Â¨ wall
  tâ€¿udlr
}

{ # part one
  udlr â† upâ€¿downâ€¿leftâ€¿right
  â€¢Show âŠ‘ (0â€¿1)â€¿(Â¯1â€¿Â¯2) MeasurePath 0â€¿udlr
}

{ # part two; assume can solve the three consecutive problems independently,
  # then add up the time. in general would need to solve it jointly though,
  # e.g. with a concatenation of three boards
  udlr â† upâ€¿downâ€¿leftâ€¿right
  t â† 0
  tâ€¿udlr â†© (0â€¿1)â€¿(Â¯1â€¿Â¯2) MeasurePath tâ€¿udlr
  tâ€¿udlr â†© (Â¯1â€¿Â¯2)â€¿(0â€¿1) MeasurePath tâ€¿udlr
  tâ€¿udlr â†© (0â€¿1)â€¿(Â¯1â€¿Â¯2) MeasurePath tâ€¿udlr
  â€¢Show t
}

