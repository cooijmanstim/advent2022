ParseNum â† 10âŠ¸Ã—âŠ¸+ËœÂ´ âˆ˜âŒ½ -âŸœ'0'
Numbers â† {ğ•Šs: ParseNumÂ¨ s âŠ”Ëœ {1-Ëœğ•©Ã—+`0âŒˆğ•©-Â»ğ•©} ('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9') s}
paths â† (<Ë˜ âˆ˜â€¿2 â¥Š Numbers)Â¨ â€¢FLines âŠ‘â€¢args

xmin â† 500âŒŠ âŒŠÂ´ âŒŠÂ´Â¨ 0âŠ¸âŠ‘Â¨Â¨ paths
xmax â† 500âŒˆ âŒˆÂ´ âŒˆÂ´Â¨ 0âŠ¸âŠ‘Â¨Â¨ paths
ymin â† 0
ymax â† âŒˆÂ´ âŒˆÂ´Â¨ 1âŠ¸âŠ‘Â¨Â¨ paths
â€¢Show âŸ¨xmin, xmaxâŸ©â€¿âŸ¨ymin, ymaxâŸ©

# for part two, add two rows on bottom, and widen to accomodate a full triangle
ymax +â†© 2
xminâ€¿xmax â†© âŸ¨500 - ymax, 500 + ymaxâŸ©

start â† 500â€¿0 - xminâ€¿ymin

blocked â† (1+xmax-xmin)â€¿(1+ymax-ymin) â¥Š 0
MarkBlocked â† {blocked 1âŒ¾ (ğ•©âŠ¸âŠ‘)â†©}
RavelIndex â† {idxğ•Šshape: +Â´ idx Ã— Ã—`âŒ¾ âŒ½  1Â« shape}
_setmany_ â† {i _ğ•£_ v x: vâŒ¾ ((RavelIndexâŸœ(â‰¢x)Â¨ i)âŠ¸âŠâˆ˜â¥Š) x}
MarkManyBlocked â† {ğ•Ši: blocked (i _setmany_ ((â‰ i)â¥Š1))â†©}
ShowBlocked â† {ğ•Šğ•©: â€¢Show â‰ âŠ‘âŸœ".#"Â¨ blocked}

# for part two, mark the floor
blocked â†© ((â‰ blocked)â¥Š1)âŒ¾ (Â¯1âŠ¸âŠË˜) blocked

{ğ•Špath: {aâ€¿b:
    direction â† Â¯1âŒˆ1âŒŠb-a â‹„ distance â† âŒˆÂ´ |b-a
    #{MarkBlocked -âŸœxminâ€¿ymin a + ğ•©Ã—direction}Â¨ â†•1+distance  # sloow
    MarkManyBlocked {-âŸœxminâ€¿ymin a + ğ•©Ã—direction}Â¨ â†•1+distance
  }Â¨ Â¯1â†“pathâ‹ˆÂ¨Â«path
}Â¨ paths
#ShowBlocked @
#â€¢Exit 1

# now simulate each unit of sand, adding it to blocked once it comes to rest
SimulateCrumb â† {ğ•Šstart:
  {ğ•Šp:
    IsBlocked â† {ğ•Šq: âˆ§Â´(0â‰¤q)âˆ§(qâ‰¤(â‰¢blocked)) ? blockedâŠ‘Ëœq; Â¯1}
    dâ€¿lâ€¿r â† pâŠ¸+Â¨ âŸ¨0â€¿1, Â¯1â€¿1, 1â€¿1âŸ©
    bdâ€¿blâ€¿br â† IsBlockedÂ¨ dâ€¿lâ€¿r
    {bdâ‰¡ 0? d; blâ‰¡ 0? l; brâ‰¡ 0? r;
     MarkBlocked p â‹„ p  # come to rest
    }
  } â€¢_while_ {@: 0; Â¬ğ•©âŠ‘blocked} start
}

{1: # part one
InAbyss â† {ğ•Šxâ€¿y: y â‰¥ ymax-2}
count â† 0
{ğ•Šdone: count+â†©1 â‹„ InAbyss SimulateCrumb start} â€¢_while_ Â¬ 0
#ShowBlocked @
â€¢Show count-1
;2: # part two
count â† 0
{ğ•Šğ•©: count+â†©1 â‹„ SimulateCrumb start} â€¢_while_ {ğ•Šğ•©: Â¬startâŠ‘blocked} 0
#ShowBlocked @
â€¢Show count
} 2

