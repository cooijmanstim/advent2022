lines â† â€¢FLines âŠ‘â€¢args

Split â† (âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢
SplitMask â† (âŠ¢-Ëœ+`Ã—Â¬)âŠ¸âŠ”
ParseNat â† 10âŠ¸Ã—âŠ¸+ËœÂ´âˆ˜âŒ½  -âŸœ'0'
TrimL â† {ğ•Šs: sâ†“Ëœ0âŠËœs=' '}
TrimR â† TrimL âŒ¾ âŒ½
Trim â† TrimL âˆ˜ TrimR
ParseOperation â† {ğ•Šs:
  parts â† ' ' Split s
  operator â† +â€¿Ã— âŠ‘Ëœ âŠ‘ "+*"âŠ âŠ‘1âŠ‘parts
  {ğ•Šold: OperatorÂ´ {ğ•Šp: {pâ‰¡"old"?old;ParseNat p}}Â¨ 1â€¿0â€¿1 / parts}
}

ParseMonkey â† {ğ•Šls:
  items â† ParseNatÂ¨ TrimÂ¨ ',' Split (â‰ "  Starting items: ")â†“ 1âŠ‘ls
  operation â† ParseOperation (â‰ "  Operation: new = ")â†“ 2âŠ‘ls
  divisor â† ParseNat (â‰ "  Test: divisible by ")â†“ 3âŠ‘ls
  branches â† âŸ¨ParseNat (â‰ "    If true: throw to monkey ")â†“ 4âŠ‘ls,
              ParseNat (â‰ "    If false: throw to monkey ")â†“ 5âŠ‘lsâŸ©
  activity â† 0
  âŸ¨items, operation, divisor, branches, activityâŸ©
}

monkeys â† ParseMonkeyÂ¨ ((""âŠ¸â‰¡Â¨âŠ¢)SplitMaskâŠ¢) lines
â€¢Show monkeys

modulus â† Ã—Â´ 2âŠ¸âŠ‘Â¨ monkeys  # NOTE could have used lcm

# NOTE dzaima used an object/namespace for each monkey, which provides mutable
# state and would be much cheaper than the modify-under-indexing updates I did
R â† {ğ•Šms:
  {ğ•Šsrc:
    itemsâ€¿operationâ€¿divisorâ€¿branchesâ€¿activity â† srcâŠ‘ms
    {ğ•Ši:
      #j â† âŒŠ 3Ã·Ëœ Operation i  # part one
      j â† Operation i  # part two
      j â†© modulus|j # modulus by product of monkeys divisors does not change dynamics of monkey business!
      dst â† branches âŠ‘Ëœ Â¬0=(divisor|j)
      #â€¢Show srcâ€¿iâ€¿jâ€¿dst
      ! Â¬dst=src  # that would modify our own items we're looping over
      ms â†© (âˆ¾âŸœ(<j))âŒ¾ (0âŠ¸âŠ‘ dstâŠ¸âŠ‘) ms
    }Â¨ items
    ms â†© (+âŸœ(â‰ items))âŒ¾ (Â¯1âŠ¸âŠ‘ srcâŠ¸âŠ‘) ms
    ms â†© âŸ¨âŸ© âŒ¾ (0âŠ¸âŠ‘ srcâŠ¸âŠ‘) ms
  }Â¨ â†•â‰ ms
  ms
}
â€¢Show R monkeys
â€¢Show RâŸ 20 monkeys

# part one:
â€¢Show Ã—Â´ 2â†‘ âˆ¨ Â¯1âŠ¸âŠ‘Â¨ RâŸ 20 monkeys
# part two:
â€¢Show Ã—Â´ 2â†‘ âˆ¨ Â¯1âŠ¸âŠ‘Â¨ RâŸ 10000 monkeys


