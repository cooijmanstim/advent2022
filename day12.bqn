board â† >â€¢FLines âŠ‘â€¢args
â€¢Show board

UnravelIndex â† {shapeğ•Šidx:
  {ğ•Šd:
    x â† d|idx
    idx âŒŠâˆ˜Ã·â†© d
    x
  }Â¨ âŒ¾ âŒ½ shape
}
IndexOf â† {hğ•Šn: (â‰¢h) UnravelIndex ((â¥Šh)âŠ¸âŠâŒ¾ < n)}

practicalinf â† â‰ â¥Šboard

start â† board IndexOf 'S'
end â† board IndexOf 'E'
board â†© (â‰¢board) â¥Š {("a"âŒ¾ ((ğ•©='S')âŠ¸/) "z"âŒ¾ ((ğ•©='E')âŠ¸/)) ğ•©} â¥Šboard
â€¢Show board

Act â† {sğ•Ša:
  ds â† a âŠ‘ âŸ¨0â€¿Â¯1, 0â€¿1, Â¯1â€¿0, 1â€¿0âŸ©
  0 âŒˆ (1-Ëœâ‰¢board) âŒŠ s + ds
}

# use Q learning to find shortest path to end from anywhere.
# dzaima used flood fill; I didn't realize that was sufficient for this problem.

# initialize q values
q â† 0â€¿0â€¿0â€¿0Â¨ board
T â† {ğ•Šq:
  q {qsğ•Šs:
    qs {qsağ•Ša:
      s2 â† s Act a
      r â† { # compute reward for the transition
        1<(s2âŠ‘board)-(sâŠ‘board) ? -practicalinf;  # punish illegal move
        s2 â‰¡ end ? 1;  # reward getting to the goal
        Â¯1  # any other move costs one step
      }
      qs2 â† s2 âŠ‘ q
      {s â‰¡ end ? 0 ; r + âŒˆÂ´ qs2}  # r + max_a2 Q(s2, a2)
    }Â¨ â†•â‰ qs
  }Â¨ â†•â‰¢q
}

qstar â† TâŸ practicalinf q
â€¢Show âŒˆÂ´Â¨ qstar

Measure â† {ğ•Šstart:
  tâ†0
  xâ†start
  {ğ•Šğ•©:
    x â‰¡ end ? @ ;
    x Actâ†© âŠ‘â’xâŠ‘qstar
    t +â†© 1
  }Â¨ â†•practicalinf
  t
}

# part one
â€¢Show Measure start
# part two
â€¢Show Measure {ğ•©âŠ‘Ëœ âŠ‘âˆ˜â’ âŒˆÂ´âˆ˜âŠ‘âŸœqstarÂ¨ ğ•©} (board = 'a') /â—‹â¥Š â†•â‰¢board

