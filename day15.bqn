ParseNat â† 10âŠ¸Ã—âŠ¸+ËœÂ´ âˆ˜âŒ½ -âŸœ'0'
ParseNum â† {ğ•Šğ•©: '-'â‰¡âŠ‘ğ•© ? -ParseNat 1â†“ğ•©; ParseNat ğ•©}
Numbers â† {ğ•Šs: ParseNumÂ¨ s âŠ”Ëœ {1-Ëœğ•©Ã—+`0âŒˆğ•©-Â»ğ•©} ('-'=s) âˆ¨ (('0' â‰¤ s) âˆ§ (s â‰¤ '9'))}
RavelIndex â† {idxğ•Šshape: +Â´ idx Ã— Ã—`âŒ¾ âŒ½  1Â« shape}
_setmany_ â† {i _ğ•£_ v x: vâŒ¾ ((RavelIndexâŸœ(â‰¢x)Â¨ i)âŠ¸âŠâˆ˜â¥Š) x}

sensors â† {ğ•Šline:
  sxâ€¿syâ€¿bxâ€¿by â† Numbers line
  r â† +Â´|sxâ€¿sy - bxâ€¿by
  sxâ€¿syâ€¿r
}Â¨ â€¢FLines âŠ‘â€¢args
#â€¢Show sensors

# part one: care only about x=10 (in example, x=2M in input)
ytarget â† 10â€¿2E6 âŠ‘Ëœ "in"â‰¡Â¯2â†‘ âŠ‘â€¢args
EmptyRange â† >Â´
IntersectRange â† (âŒˆâ—‹(0âŠ¸âŠ‘))â‹ˆ(âŒŠâ—‹(1âŠ¸âŠ‘))
UnionRange â† (âŒŠâ—‹(0âŠ¸âŠ‘))â‹ˆ(âŒˆâ—‹(1âŠ¸âŠ‘))
CountRange â† 1+ -ËœÂ´  # 1+ because inclusive

# find ranges that each sensor can see on the target row.
ranges â† {ğ•©/ËœÂ¬EmptyRangeÂ¨ğ•©} {ğ•Šxâ€¿yâ€¿r:
  rowdist â† |y-ytarget
  w â† r - rowdist
  âŸ¨x-w, x+wâŸ©
}Â¨ sensors
#â€¢Show ranges

# now merge overlapping ranges by union. the result is a set of nonoverlapping ranges.
mergedranges â† âŸ¨âŸ© {rangeğ•Šset:
  # note if multiple in set overlap with range, now they all overlap
  disjoint â† EmptyRangeÂ¨ rangeâŠ¸IntersectRangeÂ¨ set
  (disjoint / set) âˆ¾ < UnionRangeÂ´ (<range) âˆ¾ (Â¬disjoint) / set
}Â´ ranges
# now the combined coverage of the merged ranges is our answer, except we need to
# subtract the number of beacons in that area.
beacons â† {ğ•Šline:
  sxâ€¿syâ€¿bxâ€¿by â† Numbers line
  bxâ€¿by
}Â¨ â€¢FLines âŠ‘â€¢args
beaconsinranges â† {ğ•Šxâ€¿y:
  (y=ytarget) âˆ§ âˆ¨Â´ {ğ•Šrange: Â¬EmptyRange xâ€¿x IntersectRange range}Â¨ mergedranges
}Â¨ â· beacons
â€¢Show (+Â´ CountRangeÂ¨ mergedranges) - +Â´ beaconsinranges

# part two
extent â† 20â€¿4E6 âŠ‘Ëœ "in"â‰¡Â¯2â†‘âŠ‘â€¢args
TuningFreq â† {ğ•Šx: +Â´ xÃ—4E6â€¿1}
# there is a single point p that is just out of reach of four (or more) sensors.
# if we increase their radius by 1, then it is on the perimeter of these sensors.
# so we only need to consider points that are on intersections of sensor perimeters.
Solve22 â† {mğ•Šv:
  wâ€¿xâ€¿yâ€¿z â† â¥Šm
  Ã·âŸœ((wÃ—z)-(xÃ—y)) +ËË˜ vâŠ¸Ã—Ë˜ 2â€¿2 â¥Š [z, -x, -y, w]
}
IntersectLine â† {aâ€¿bğ•Šcâ€¿d:
  # solve 2d system a + alpha (b-a) = c + beta (d-c)
  coeff â† (â‰ [b-a, -(d-c)]) Solve22 c-a
  âˆ§Â´ (0â‰¤coeff)âˆ§(coeffâ‰¤1) ? a+(b-a)Ã—âŠ‘coeff; @
}
#â€¢Show âŸ¨0â€¿0,1â€¿1âŸ© IntersectLine âŸ¨1â€¿0,0â€¿1âŸ©
#â€¢Show âŸ¨0â€¿0,0â€¿1âŸ© IntersectLine âŸ¨1â€¿0,1â€¿1âŸ©
PerimeterSegments â† {ğ•Šxâ€¿yâ€¿r:
  cs â† xâ€¿yâŠ¸+Â¨ <Ë˜ rÃ— âˆ˜â€¿2 â¥Š 0â€¿Â¯1â€¿Â¯1â€¿0â€¿0â€¿1â€¿1â€¿0  # corners
  <Ë˜ 2â†• cs âˆ¾ âŠcs
}
Enumerate â† {ğ•Šxs: (â†•â‰ xs)â‹ˆÂ¨xs}
candidates â† âŸ¨âŸ©
{ğ•Šiâ€¿a:
  {ğ•Šjâ€¿b:
    xaâ€¿yaâ€¿ra â† a â‹„ xbâ€¿ybâ€¿rb â† b
    intersections â† â¥Š (PerimeterSegments a+0â€¿0â€¿1) IntersectLineâŒœ (PerimeterSegments b+0â€¿0â€¿1)
    mask â† {@: 0; ğ•Šp: âˆ§Â´ ((âŒŠ=âŠ¢)p) âˆ§ (0â‰¤p) âˆ§ (pâ‰¤extent)}Â¨ intersections
    candidates âˆ¾â†© mask / intersections
  }Â¨ (i+1)â†“ Enumerate sensors
}Â¨ Enumerate sensors
candidates â·â†©
#â€¢Show candidates
â€¢Show â‰ candidates

# now find the candidate that is not in the range of any sensor
outofrange â† {ğ•Šp:
  âˆ§Â´ {ğ•Šxâ€¿yâ€¿r: r<+Â´|p-xâ€¿y}Â¨ sensors
}Â¨ candidates
â€¢Show TuningFreqÂ¨ â€¢Show outofrange / candidates

